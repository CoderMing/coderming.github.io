<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[deming的博客]]></title>
  <link href="coderming.github.io/atom.xml" rel="self"/>
  <link href="coderming.github.io/"/>
  <updated>2020-06-23T17:34:55+08:00</updated>
  <id>coderming.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[在腾讯实习的两个多月，我学到了什么？]]></title>
    <link href="coderming.github.io/15929046685633.html"/>
    <updated>2020-06-23T17:31:08+08:00</updated>
    <id>coderming.github.io/15929046685633.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>作者于 2019 年 1 月份开始在腾讯深圳 PCG 实习了两个多月，在此将所习得的知识分享给大家。作者技术栈为前端，但文章内容大多为实习期的「经验」与「想法」，具有普适性。</p>
</blockquote>

<p>[image:8047CCCF-E48A-4BB3-94B9-FA8842E60939-5420-00034D9AC92CD792/9138260F5A0DF9D7F427FEEE6174EEA0.png]</p>

<blockquote>
<p>题图：学校的樱花。</p>
</blockquote>

<p>学校的樱花开了，上次见还是枯枝一片。</p>

<p>转瞬间两个余月已过，也到了我腾讯寒假实习结束的时候了。</p>

<p>还记得初来深圳时的兴奋，而现在离职的不舍却更甚之。在这两个多月里，我真真切切地感受到了腾讯的企业文化。无论是自由开放的办公氛围，还是全方位关怀的员工福利，都让我感到惊喜。</p>

<p>当然，出来实习收获最大的是在公司的实习经历。作为一名象牙塔内的学生，这两个月时间对我的意义无疑是极其宝贵的。在此，我将这次实习期中所得到的一些感悟写成此文，分享给大家。</p>

<h2 id="toc_0">直面失意</h2>

<p>在我刚来到公司的时候，一腔热血的我被配环境折腾得毫无动力，同时看到周围前辈同事可以碾压我的实力，顿觉自己太菜了，打酱油都不够格。这种理想与现实间巨大的差距，让我逐渐意识到，自己的能力并没有想象中那么强，公司里的开发环境并没有想象中那么美好。</p>

<p>在你拿到实习 offer 的那一刻，你是什么想法？我想大多数人都会觉得自己会在公司大展身手。此情此景，有没有想到高考录取结果出来的时候？那时的我们一样狂妄地说要拿国奖要保研，但最后 90% 的同学都会归于平庸。究其原因，是 <strong>我们在尚未了解新环境的情况下很容易错估自己的实力，而多数人无法接受不如预期的自己。</strong> 之前看到过腾讯校招 HR 留给应届生的一段话，我觉得放在这里很合适，愿你我一起共勉。</p>

<blockquote>
<p>未来对于很多人来说一个很大的风险就是如何去面对没有想象中美好的生活，这是比技术、比工作效率更底层的修炼。不能直面失意，人生终将碌碌无为。</p>
</blockquote>

<h2 id="toc_1">多查，多问</h2>

<p>在腾讯，每一位实习生都会有一位导师指路。同时公司内也会有很多资源可供学习，这些都是可以用来在工作过程中提供帮助的。有问题可以先查资料，实在查不到就直接向导师或者其他前辈寻求帮助。</p>

<p>每一个实习生刚来到公司的第一件事一定是配环境。由于不同项目采用的技术栈不尽相同，外加上公司内繁琐的权限申请流程，如果没有一个人手把手教的话可能会卡很久。这个时候请不要自己一个人摸索，有不熟悉的流程主动去找导师。因为他轻车熟路的 10 分钟，会比你自己鼓捣一个下午更有用。同时有一些操作是你无法自己探索到的——之前部署代码在测试环境出现了 bug，我以为只能通过开发环境不停地试，结果询问导师后给了我一个测试机的账号，我直接登上去查 log，很快就定位了报错。如果我当时不问，可能就会被这种蒙住双眼的 debug 方式耗上半天。</p>

<p>这里有同学会想了：“我这样烦导师，会不会不太好啊？”我在与导师谈心的时候聊过这个问题，他的回答让我放下了担忧：“是很烦啊！但是谁不是这样过来的呢？” 是啊，谁不是麻烦别人指导过来的呢？ <strong>前辈们也都是通情达理的人，只要你有求知的热情和不耻下问的态度，他们也都会包容你的。</strong></p>

<h2 id="toc_2">以正式员工的标准来要求自己</h2>

<p>我们组的前辈们都是比我经验多很多的大牛，这让我在最开始与他们的交流中畏手畏脚，总会担心问的问题太简单让别人笑话，但我啥都不敢说也就意味着啥都学不到。入职几天后，leader 找我聊天，我将自己的苦恼丢了出来，他首先安慰我每一个新人都是这样过来的，其次纠正了我对自己的错误定位。他说到，虽然你是以实习生身份进来的，但是在大家眼里 <strong>我们都是公司员工，无分等级。</strong> </p>

<p>之后我试着用正式员工的标准要求自己，与别人交流时不要总担心问题太愚蠢，需求评审的时候不要觉得自己没发言权（不要怕怼产品hhh）。果然，以一种平等的身份去与人交流，效率就会高很多。当我破除了内心给自己预设的「实习生」枷锁后，我真真切切地感受到了自己思维和态度上的提升。毕竟一名优秀的实习生就是未来的正式员工， <strong>与其让时间推动你的成长，不如突破自我设限，以先入为主态度来要求自己。</strong></p>

<h2 id="toc_3">让别人觉得你「靠谱」</h2>

<p>「靠谱」是对一个人最重要的评价之一，它意味着信任。而我作为一名未被认可的实习生，就需要用表现赢得别人的信任。下面是我总结到的几点：</p>

<ul>
<li><strong>让别人能经常得到你的反馈。</strong> 实习生一般都会要求写日报，这就是为了让导师能及时了解你当前的状态。同理，我们在与他人合作时，最好定期主动汇报当前的开发进度，让别人能感受到你正在做事。在开发过程中遇到了问题，及时提出问题并附上自己的思考，让别人了解你面对问题是会主动思考的。如果你不主动去反馈，等别人想起你来催你的话，你就可能会被打上「挤牙膏」的印象。</li>
<li><strong>不轻易做承诺，但承诺必行。</strong> 承诺是给别人的定心丸，它的说服力取决于别人是否认为你可靠。而一个满嘴跑火车给承诺的人基本上是不可靠的。同时言出必行是我们营造可靠印象的最佳方式。在公司内，如果一个需求流转到你这里了要进行排期，请给自己预留充足的时间。打比方说一个需求你最终做完需要3天时间，但你当时答应的是两天出货，别人就会认为你不靠谱，但如果你当时答应的是4天，那你就是超出预期。结果虽然相同，但给别人的印象却截然不同。如果在做需求的过程中发现的确做不完了，一定要第一时间反馈给大家，及时采取措施来确保需求顺利完成。如果你选择死扛到上线前一天再说做不完了，造成的损失就不只是别人对你的印象了。</li>
<li><strong>先规划好，再去行动。</strong> 在公司内，比较大的需求都会进行评审，这就是为了让大家对整个需求的流程有一个理解和规划。抛离需求不谈，我们在日常写代码之前也应该有这样的前奏。做任何事前先把开发规划做出来，然后给导师审阅。这样其一是可以让导师及时纠正你逻辑的不足之处，其二是可以让导师了解你的思维。</li>
<li><strong>向大家展示你的技术输出。</strong> 在保证基本任务完成的情况下，可以让自己有一些技术输出。我平常喜欢翻译文章，于是就利用闲暇时间翻译了几篇。之前为了方便未来新人配环境，我就给自己总结了点指南。这样做其一是让自己有一些成长，其二是给你自己塑造一个富有热情和思想的正面形象，提高对你的认可度。</li>
</ul>

<h2 id="toc_4">良好的沟通是一切的基础</h2>

<p>沟通的重要性不言而喻。我曾认为我自己是一个善于沟通的人，但来到公司后却发现自己这块欠缺的太多了。下面是几点心得：</p>

<ul>
<li><strong>沟通前先组织好语言，最好画思维图。</strong> 我有一个毛病，就是每次交流的时候都希望能把所有可能有用的信息都丢给对方。但在公司里别人不会给你机会说这么多。这时候你就需要在沟通前把逻辑先理清楚，分清楚主次，有针对性地进行交流。</li>
<li><strong>注意换位思考。</strong> 在与产品就一个需求讨论时，以技术的角度去解释不一定能让被人听得懂。需求是给用户用的，我们就应该从用户的角度出发，去沟通需求。</li>
<li><strong>阐述事实要说全，不要夹杂自己的加工。</strong> 有一个著名的沟通问题叫做 “X-Y”问题，大意是你想解决 X 问题，但却向别人求助 Y 问题（因为你觉得 Y 是 X 的解决方案），最后事实证明 X 与 Y 毫无关系，导致了一次无效的沟通。这就说明在阐述问题阶段，我们不要夹杂自己的加工，要让别人能不受干扰地去帮你解决问题。</li>
<li><strong>线下永远比线上的交流管用。</strong> 有一次测试测出了一个bug，经过一小时的线上沟通后我们仍未解决。然后我线下找到他，操作他的电脑后 5 分钟处理好了。线上数据传输的媒介只能是文字、语音，但线下我们的沟通互动性更强，也就会更高效。</li>
</ul>

<p>最后，我推荐给大家两份资料：<a href="https://github.com/tvvocold/How-To-Ask-Questions-The-Smart-Way">《提问的智慧》中文版</a> 和 <a href="https://github.com/atian25/blog/issues/29">记录一些常见的沟通问题</a>。</p>

<h2 id="toc_5">要有团队意识</h2>

<p>组内多人协作，这也是我在公司内学习到的很重要的一部分。总结如下：</p>

<ul>
<li><strong>定需求的时候要去参考他人的进度。</strong> 之前有负责过一个和后台合作的需求，我这边必须得等后端完成后才可以继续开发。这时候项目排期就要考虑到后台那边的进度了。同理，项目在进行过程中，我们也要去把握住他人的进度，来看自己会不会受到影响，需不需要去帮忙。</li>
<li><strong>写代码要去考虑他人，文档很重要。</strong> 之前做一个需求的时候没有分清楚开发环境和线上环境，导致一个 Server 在多处跑，这就是我没有考虑他人的结果。除此之外，包括代码内的注释，也要尽可能地写全。某些有特定功能的代码都需要清楚注释。同理，如果有一个新 feature 实现了，最好跟进一份文档，来让大家都能弄明白使用方式。</li>
</ul>

<p>不过作为一名实习生，我并没有过多机会接触到组内协作以及大型项目的开发。我想这也是我日后所需学习的一大方面。</p>

<h2 id="toc_6">保持主动，保持热情</h2>

<p>此段的标题是我的座右铭，也是我大学以来一直践行的信条。</p>

<p>第一次和导师谈心的时候提到了这样的话题：怎么样才能在实习生中脱颖而出？他的回答是： <strong>在完成好本职工作的前提下，能有自己的想法和求知欲。</strong> 总之来说，完成 leader 给你的任务只是基本要求，想要做到杰出，就要有自己的想法。</p>

<ul>
<li><strong>写代码时考虑如何做到更好。</strong> 之前做一个线上项目时，涉及到一个数据库查询性能优化的问题。当时我觉得自己可以写一个缓存类，就动手实践了下，后来在与前辈们交流的过程中，他们针对我写的这个类提了很多优化的建议，包括 LRU/LFU，增加钩子函数等等。再往后我发现项目是多线进程的，进程间内存不共用，于是我就去看了项目框架的源码，进而了解到了 NodeJS IPC、多进程管理、Redis 的相关知识。</li>
<li><strong>不要放过学习的机会。</strong> 我们组有一个比较大的新项目，进入了 CodeReview 流程。按理来说这个项目我没有参与过开发，但我还是提出了参与申请。于是在 CodeReview 之前我去粗略地看了一遍那个项目的代码，等到 CodeReview 时我尽量地去理解几位前辈的讲话，了解他们开发时的一些思想，去思考为什么这么做。</li>
<li><strong>主动 show 自己。</strong> 有段时间我把手中的需求做完了，就去查看组内剩余的需求单。然后找到了一个「机器人助手」的优化需求，因为自己比较感兴趣，于是在有了大概技术方案后主动请缨把这个活揽了下来。后面这个需求越做越大，本来只是写一个定时器脚本，最后演变成了三个模块，不仅服务于小组内，也具备了服务于其他团队的能力。</li>
</ul>

<h2 id="toc_7">结语</h2>

<p>这两个月时间挺累的，不只是身体上的累，更多的是以学生思维在公司环境中的不适应。我想每一位同学都会经历这个过程吧——我们正如璞玉，匿于石中只将平凡暗淡，历经雕琢才能熠熠生辉。</p>

<p>纵使千般留恋，我仍要拾起这段经历，走向下一段路途。而这两个月的收获，我必铭记于心。</p>

<p>（完）</p>

<hr/>

<blockquote>
<p>作者为 2020 届前端方向本科生。如果您是前端界的前辈，或是一起同行的小伙伴，欢迎加我 wx：coderming98。期待每一位朋友🍻</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Timing Attack的原理和实用库 cryptiles]]></title>
    <link href="coderming.github.io/15929046514995.html"/>
    <updated>2020-06-23T17:30:51+08:00</updated>
    <id>coderming.github.io/15929046514995.html</id>
    <content type="html"><![CDATA[
<p>最近在刷node的基础知识，偶然间看到了Node中的“Timing Attack”问题。于是尝试深入了解了一下，就有了这篇文章👇</p>

<h2 id="toc_0">什么是 Timing Attack？cryptiles 是做什么用的？</h2>

<p>Timing Attack，直译过来就是“时间攻击”。是利用了语言引擎比对两个字符串的实现方法来进行的攻击。<br/>
对于JS引擎，匹配两个字符串是否相等，是做以下两件事：<br/>
    - 查看两个字符串长度是否有为0的，如果都为0就返回true，只有一个为0就返回false<br/>
    - 从字符串的第0个元素开始，比对两个字符串对应的字符是否相同。如果不同，就返回false。这样一直运行到两个字符串都结尾，如果结尾的标志符（在C语言中是<code>&#39;\0&#39;</code>，在JS的引擎实现不清楚)都一样的话，就返回true<br/>
对于这个实现算法，我们知道<strong>其运行时间并非稳定</strong>的。因为开头正确位数不一样，所以匹配时间也不一样。而Timing Attack就是利用了匹配时间上的差距，来猜测匹配的字符串对了几位。</p>

<h2 id="toc_1">有什么解决方案？</h2>

<p>Node官方自带的 <code>crypto</code>模块就有解决方案。具体的API可以看这里：<a href="http://nodejs.cn/api/crypto.html#crypto_crypto_timingsafeequal_a_b">crypto | Node.js API 文档</a>（目前只有英文）<br/>
那 cryptiles 是做什么的呢？就是一个避免 Timing Attack 的工具。具体请看：<br/>
<a href="https://github.com/hapijs/cryptiles">GitHub - hapijs/cryptiles: General purpose crypto utilities</a></p>

<p>有了这些工具，就可以很显著地避免这个问题了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅析阿里2018秋招前端编程测验题]]></title>
    <link href="coderming.github.io/15928819115606.html"/>
    <updated>2020-06-23T11:11:51+08:00</updated>
    <id>coderming.github.io/15928819115606.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">先上题</h3>

<pre><code class="language-javascript">// 实现一个函数，传入一个promise数组。要求数组中的函数按顺序依次执行，最后函数的返回值是一个由数组元素中各个promise返回值组成的数组
const timeout = ms =&gt; new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve();
    }, ms);
});

const ajax1 = () =&gt; timeout(2000).then(() =&gt; {
    console.log(&#39;1&#39;);
    return 1;
});

const ajax2 = () =&gt; timeout(1000).then(() =&gt; {
    console.log(&#39;2&#39;);
    return 2;
});

const ajax3 = () =&gt; timeout(2000).then(() =&gt; {
    console.log(&#39;3&#39;);
    return 3;
});

const mergePromise = ajaxArray =&gt; {
  // 填写此处的代码
};

mergePromise([ajax1, ajax2, ajax3]).then(data =&gt; {
    console.log(&#39;done&#39;);
    console.log(data); // data 为 [1, 2, 3]
});
</code></pre>

<h3 id="toc_1">分析</h3>

<p>可以看到这个题是考我们对于promise的理解，算是较为基础的题。<br/>
首先我们看到最后函数执行完成后是一个then方法。那么我们就可以知道，<code>mergePromise</code>函数的返回值是一个promise。那么什么东西执行后会返回一个promise呢？无非就两种：一种是promise自身，一种是<code>async function</code>。<br/>
其次，我们看到传入<code>mergePromise</code>函数的参数，是一个长度不定的数组。处理长度不定的数组的各个元素，无非就是循环或者类循环了。即forEach，for循环这些。<br/>
根据上面两点，我想到了用<code>async function</code>。</p>

<h3 id="toc_2">本人的解法</h3>

<pre><code class="language-javascript">  return (async function() {
    let index = 0, length = ajaxArray.length, dataArr = []
    while(index !== length) {
      dataArr.push(await ajaxArray[index++]())
    } 
    return dataArr
  })()
</code></pre>

]]></content>
  </entry>
  
</feed>
